{"ast":null,"code":"import devAssert from '../jsutils/devAssert';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext';\nexport var ABORT_VALIDATION = Object.freeze({});\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 ? arguments[4] : undefined;\n  documentAST || devAssert(0, 'Must provide document'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var maxErrors = options && options.maxErrors;\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (maxErrors != null && errors.length >= maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n} // @internal\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}","map":{"version":3,"names":["devAssert","GraphQLError","visit","visitInParallel","visitWithTypeInfo","assertValidSchema","TypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","ABORT_VALIDATION","Object","freeze","validate","schema","documentAST","rules","arguments","length","undefined","typeInfo","options","abortObj","errors","maxErrors","context","error","push","visitor","map","rule","e","validateSDL","schemaToExtend","visitors","assertValidSDL","Error","message","join","assertValidSDLExtension"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import devAssert from '../jsutils/devAssert';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { visit, visitInParallel, visitWithTypeInfo } from '../language/visitor';\nimport { assertValidSchema } from '../type/validate';\nimport { TypeInfo } from '../utilities/TypeInfo';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext';\nexport var ABORT_VALIDATION = Object.freeze({});\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 ? arguments[4] : undefined;\n  documentAST || devAssert(0, 'Must provide document'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var maxErrors = options && options.maxErrors;\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (maxErrors != null && errors.length >= maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n} // @internal\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}