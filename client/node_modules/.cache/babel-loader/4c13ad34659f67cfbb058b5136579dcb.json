{"ast":null,"code":"var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isTypeDefinitionNode } from '../../language/predicates';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from '../../type/definition';\nexport function extendingUnknownTypeMessage(typeName, suggestedTypes) {\n  return \"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\nexport function extendingDifferentTypeKindMessage(typeName, kind) {\n  return \"Cannot extend non-\".concat(kind, \" type \\\"\").concat(typeName, \"\\\".\");\n}\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensions(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema && schema.getType(typeName);\n\n    if (defNode) {\n      var expectedKind = defKindToExtKind[defNode.kind];\n\n      if (expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(expectedKind)), [defNode, node]));\n      }\n    } else if (existingType) {\n      var _expectedKind = typeToExtKind(existingType);\n\n      if (_expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(_expectedKind)), node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(extendingUnknownTypeMessage(typeName, suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  } else if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  } else if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  } else if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  } else if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } else if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n\n    default:\n      return 'unknown type';\n  }\n}","map":{"version":3,"names":["_defKindToExtKind","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","didYouMean","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","extendingUnknownTypeMessage","typeName","suggestedTypes","concat","map","x","extendingDifferentTypeKindMessage","kind","PossibleTypeExtensions","context","schema","getSchema","definedTypes","create","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","defNode","existingType","getType","expectedKind","defKindToExtKind","reportError","extensionKindToTypeName","_expectedKind","typeToExtKind","allTypeNames","keys","getTypeMap","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/validation/rules/PossibleTypeExtensions.mjs"],"sourcesContent":["var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { isTypeDefinitionNode } from '../../language/predicates';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from '../../type/definition';\nexport function extendingUnknownTypeMessage(typeName, suggestedTypes) {\n  return \"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\nexport function extendingDifferentTypeKindMessage(typeName, kind) {\n  return \"Cannot extend non-\".concat(kind, \" type \\\"\").concat(typeName, \"\\\".\");\n}\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\n\nexport function PossibleTypeExtensions(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema && schema.getType(typeName);\n\n    if (defNode) {\n      var expectedKind = defKindToExtKind[defNode.kind];\n\n      if (expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(expectedKind)), [defNode, node]));\n      }\n    } else if (existingType) {\n      var _expectedKind = typeToExtKind(existingType);\n\n      if (_expectedKind !== node.kind) {\n        context.reportError(new GraphQLError(extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(_expectedKind)), node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(extendingUnknownTypeMessage(typeName, suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  } else if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  } else if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  } else if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  } else if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } else if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n\n    default:\n      return 'unknown type';\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}