{"ast":null,"code":"import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","specifiedDirectives","duplicateDirectiveMessage","directiveName","concat","UniqueDirectivesPerLocation","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","enter","node","directives","knownDirectives","_i6","_directive","reportError"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs"],"sourcesContent":["import { GraphQLError } from '../../error/GraphQLError';\nimport { Kind } from '../../language/kinds';\nimport { specifiedDirectives } from '../../type/directives';\nexport function duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at this location.\");\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\n\nexport function UniqueDirectivesPerLocation(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      // so we cast so the rest of the code is well typed.\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n\n        for (var _i6 = 0; _i6 < directives.length; _i6++) {\n          var _directive = directives[_i6];\n          var directiveName = _directive.name.value;\n\n          if (uniqueDirectiveMap[directiveName]) {\n            if (knownDirectives[directiveName]) {\n              context.reportError(new GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));\n            } else {\n              knownDirectives[directiveName] = _directive;\n            }\n          }\n        }\n      }\n    }\n  };\n}\n"],"mappings":"AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,IAAT,QAAqB,sBAArB;AACA,SAASC,mBAAT,QAAoC,uBAApC;AACA,OAAO,SAASC,yBAAT,CAAmCC,aAAnC,EAAkD;EACvD,OAAO,mBAAmBC,MAAnB,CAA0BD,aAA1B,EAAyC,4CAAzC,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,2BAAT,CAAqCC,OAArC,EAA8C;EACnD,IAAIC,kBAAkB,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAzB;EACA,IAAIC,MAAM,GAAGJ,OAAO,CAACK,SAAR,EAAb;EACA,IAAIC,iBAAiB,GAAGF,MAAM,GAAGA,MAAM,CAACG,aAAP,EAAH,GAA4BZ,mBAA1D;;EAEA,KAAK,IAAIa,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,iBAAiB,CAACG,MAA1C,EAAkDD,GAAG,EAArD,EAAyD;IACvD,IAAIE,SAAS,GAAGJ,iBAAiB,CAACE,GAAD,CAAjC;IACAP,kBAAkB,CAACS,SAAS,CAACC,IAAX,CAAlB,GAAqC,CAACD,SAAS,CAACE,YAAhD;EACD;;EAED,IAAIC,cAAc,GAAGb,OAAO,CAACc,WAAR,GAAsBC,WAA3C;;EAEA,KAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,cAAc,CAACJ,MAAvC,EAA+CO,GAAG,EAAlD,EAAsD;IACpD,IAAIC,GAAG,GAAGJ,cAAc,CAACG,GAAD,CAAxB;;IAEA,IAAIC,GAAG,CAACC,IAAJ,KAAaxB,IAAI,CAACyB,oBAAtB,EAA4C;MAC1ClB,kBAAkB,CAACgB,GAAG,CAACN,IAAJ,CAASS,KAAV,CAAlB,GAAqC,CAACH,GAAG,CAACI,UAA1C;IACD;EACF;;EAED,OAAO;IACL;IACA;IACA;IACAC,KAAK,EAAE,SAASA,KAAT,CAAeC,IAAf,EAAqB;MAC1B;MACA;MACA,IAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;;MAEA,IAAIA,UAAJ,EAAgB;QACd,IAAIC,eAAe,GAAGvB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAtB;;QAEA,KAAK,IAAIuB,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,UAAU,CAACf,MAAnC,EAA2CiB,GAAG,EAA9C,EAAkD;UAChD,IAAIC,UAAU,GAAGH,UAAU,CAACE,GAAD,CAA3B;UACA,IAAI7B,aAAa,GAAG8B,UAAU,CAAChB,IAAX,CAAgBS,KAApC;;UAEA,IAAInB,kBAAkB,CAACJ,aAAD,CAAtB,EAAuC;YACrC,IAAI4B,eAAe,CAAC5B,aAAD,CAAnB,EAAoC;cAClCG,OAAO,CAAC4B,WAAR,CAAoB,IAAInC,YAAJ,CAAiBG,yBAAyB,CAACC,aAAD,CAA1C,EAA2D,CAAC4B,eAAe,CAAC5B,aAAD,CAAhB,EAAiC8B,UAAjC,CAA3D,CAApB;YACD,CAFD,MAEO;cACLF,eAAe,CAAC5B,aAAD,CAAf,GAAiC8B,UAAjC;YACD;UACF;QACF;MACF;IACF;EAzBI,CAAP;AA2BD"},"metadata":{},"sourceType":"module"}