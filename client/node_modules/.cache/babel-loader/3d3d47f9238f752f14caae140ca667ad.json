{"ast":null,"code":"import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder = /*#__PURE__*/function () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n\n    return this.getNamedType(node);\n  };\n\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n    /* istanbul ignore next */\n\n\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}","map":{"version":3,"names":["objectValues","keyMap","inspect","invariant","devAssert","keyValMap","Kind","TokenKind","parse","isTypeDefinitionNode","dedentBlockStringValue","assertValidSDL","getDirectiveValues","specifiedScalarTypes","introspectionTypes","GraphQLSchema","GraphQLDirective","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","valueFromAST","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaDef","typeDefs","directiveDefs","_i2","_documentAST$definiti2","definitions","length","def","SCHEMA_DEFINITION","push","DIRECTIVE_DEFINITION","astBuilder","ASTDefinitionBuilder","typeName","type","typeMap","undefined","Error","concat","keyByNameNode","node","buildType","operationTypes","getOperationTypes","query","mutation","subscription","directives","map","buildDirective","some","directive","name","types","astNode","allowedLegacyNames","schema","opTypes","_i4","_schema$operationType2","operationType","operation","value","stdTypeMap","resolveType","_options","_resolveType","_proto","prototype","getNamedType","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_this","locations","_ref","description","getDescription","isRepeatable","repeatable","args","arguments","arg","buildArg","buildField","field","_this2","deprecationReason","getDeprecationReason","defaultValue","buildInputField","buildEnumValue","OBJECT_TYPE_DEFINITION","_makeTypeDef","INTERFACE_TYPE_DEFINITION","_makeInterfaceDef","ENUM_TYPE_DEFINITION","_makeEnumDef","UNION_TYPE_DEFINITION","_makeUnionDef","SCALAR_TYPE_DEFINITION","_makeScalarDef","INPUT_OBJECT_TYPE_DEFINITION","_makeInputObjectDef","_this3","interfaceNodes","interfaces","fieldNodes","fields","ref","Object","create","_this4","_this5","valueNodes","values","_this6","typeNodes","_this7","list","valFn","_ref2","deprecated","reason","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join","buildSchema","source"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import objectValues from '../polyfills/objectValues';\nimport keyMap from '../jsutils/keyMap';\nimport inspect from '../jsutils/inspect';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { TokenKind } from '../language/tokenKind';\nimport { parse } from '../language/parser';\nimport { isTypeDefinitionNode } from '../language/predicates';\nimport { dedentBlockStringValue } from '../language/blockString';\nimport { assertValidSDL } from '../validation/validate';\nimport { getDirectiveValues } from '../execution/values';\nimport { specifiedScalarTypes } from '../type/scalars';\nimport { introspectionTypes } from '../type/introspection';\nimport { GraphQLSchema } from '../type/schema';\nimport { GraphQLDirective, GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from '../type/directives';\nimport { GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull } from '../type/definition';\nimport { valueFromAST } from './valueFromAST';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDL(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var directiveDefs = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Type \\\"\".concat(typeName, \"\\\" not found in document.\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyByNameNode(typeDefs, function (node) {\n    return astBuilder.buildType(node);\n  });\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  var directives = directiveDefs.map(function (def) {\n    return astBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: operationTypes.query ? typeMap[operationTypes.query] : null,\n    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,\n    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,\n    types: objectValues(typeMap),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n\n    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {\n      var operationType = _schema$operationType2[_i4];\n      opTypes[operationType.operation] = operationType.type.name.value;\n    }\n\n    return opTypes;\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\nexport var ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(options, resolveType) {\n    this._options = options;\n    this._resolveType = resolveType;\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.getNamedType = function getNamedType(node) {\n    var name = node.name.value;\n    return stdTypeMap[name] || this._resolveType(name);\n  };\n\n  _proto.getWrappedType = function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(this.getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(this.getWrappedType(node.type));\n    }\n\n    return this.getNamedType(node);\n  };\n\n  _proto.buildDirective = function buildDirective(directive) {\n    var _this = this;\n\n    var locations = directive.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: directive.name.value,\n      description: getDescription(directive, this._options),\n      locations: locations,\n      isRepeatable: directive.repeatable,\n      args: keyByNameNode(directive.arguments || [], function (arg) {\n        return _this.buildArg(arg);\n      }),\n      astNode: directive\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    var _this2 = this;\n\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this.getWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: keyByNameNode(field.arguments || [], function (arg) {\n        return _this2.buildArg(arg);\n      }),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildArg = function buildArg(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    // with validateSchema() will produce more actionable results.\n    var type = this.getWrappedType(value.type);\n    return {\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: valueFromAST(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto.buildType = function buildType(astNode) {\n    var name = astNode.name.value;\n\n    if (stdTypeMap[name]) {\n      return stdTypeMap[name];\n    }\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(astNode);\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(astNode);\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(astNode);\n\n      case Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(astNode);\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(astNode);\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(astNode);\n    } // Not reachable. All possible type definition nodes have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(astNode) {\n    var _this3 = this;\n\n    var interfaceNodes = astNode.interfaces;\n    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {\n      return interfaceNodes.map(function (ref) {\n        return _this3.getNamedType(ref);\n      });\n    } : [];\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this3.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLObjectType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      interfaces: interfaces,\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {\n    var _this4 = this;\n\n    var fieldNodes = astNode.fields;\n    var fields = fieldNodes && fieldNodes.length > 0 ? function () {\n      return keyByNameNode(fieldNodes, function (field) {\n        return _this4.buildField(field);\n      });\n    } : Object.create(null);\n    return new GraphQLInterfaceType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      fields: fields,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(astNode) {\n    var _this5 = this;\n\n    var valueNodes = astNode.values || [];\n    return new GraphQLEnumType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      values: keyByNameNode(valueNodes, function (value) {\n        return _this5.buildEnumValue(value);\n      }),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(astNode) {\n    var _this6 = this;\n\n    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    var types = typeNodes && typeNodes.length > 0 ? function () {\n      return typeNodes.map(function (ref) {\n        return _this6.getNamedType(ref);\n      });\n    } : [];\n    return new GraphQLUnionType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      types: types,\n      astNode: astNode\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(astNode) {\n    return new GraphQLScalarType({\n      name: astNode.name.value,\n      description: getDescription(astNode, this._options),\n      astNode: astNode\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    var fields = def.fields;\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: fields ? function () {\n        return keyByNameNode(fields, function (field) {\n          return _this7.buildInputField(field);\n        });\n      } : Object.create(null),\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n\nfunction keyByNameNode(list, valFn) {\n  return keyValMap(list, function (_ref2) {\n    var name = _ref2.name;\n    return name.value;\n  }, valFn);\n}\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nexport function buildSchema(source, options) {\n  return buildASTSchema(parse(source, options), options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}