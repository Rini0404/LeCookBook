{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n    /* istanbul ignore next */\n\n\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","flatMap","objectValues","inspect","mapValue","invariant","devAssert","keyValMap","Kind","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","GraphQLDirective","isSpecifiedScalarType","isIntrospectionType","assertSchema","GraphQLSchema","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","ASTDefinitionBuilder","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","typeDefs","typeExtsMap","create","directiveDefs","schemaDef","schemaExts","_i2","_documentAST$definiti2","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","extendedTypeName","name","existingTypeExts","concat","DIRECTIVE_DEFINITION","schemaConfig","toConfig","astBuilder","typeName","type","typeMap","undefined","Error","node","buildType","_i4","_schemaConfig$types2","types","existingType","extendNamedType","operationTypes","query","mutation","subscription","_i6","_schemaDef$operationT2","_ref2","operation","_i8","schemaExt","_i10","_schemaExt$operationT2","_ref4","_operation","_type","allowedLegacyNames","getMaybeTypeByName","directives","getMergedDirectives","astNode","extensionASTNodes","replaceType","ofType","replaceNamedType","existingDirectives","getDirectives","map","extendDirective","buildDirective","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","directive","config","args","extendArg","extensions","fieldNodes","fields","field","buildInputField","valueNodes","values","buildEnumValue","interfaceNodes","interfaces","getInterfaces","getNamedType","extendField","buildField","typeNodes","getTypes","arg"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport flatMap from '../polyfills/flatMap';\nimport objectValues from '../polyfills/objectValues';\nimport inspect from '../jsutils/inspect';\nimport mapValue from '../jsutils/mapValue';\nimport invariant from '../jsutils/invariant';\nimport devAssert from '../jsutils/devAssert';\nimport keyValMap from '../jsutils/keyValMap';\nimport { Kind } from '../language/kinds';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates';\nimport { assertValidSDLExtension } from '../validation/validate';\nimport { GraphQLDirective } from '../type/directives';\nimport { isSpecifiedScalarType } from '../type/scalars';\nimport { isIntrospectionType } from '../type/introspection';\nimport { assertSchema, GraphQLSchema } from '../type/schema';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition';\nimport { ASTDefinitionBuilder } from './buildASTSchema';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST');\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    assertValidSDLExtension(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefs = [];\n  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExts = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExts.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExts = typeExtsMap[extendedTypeName];\n      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var schemaConfig = schema.toConfig();\n  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {\n    var type = typeMap[typeName];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(typeName, \"\\\".\"));\n    }\n\n    return type;\n  });\n  var typeMap = keyValMap(typeDefs, function (node) {\n    return node.name.value;\n  }, function (node) {\n    return astBuilder.buildType(node);\n  });\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  } // Get the extended root operation types.\n\n\n  var operationTypes = {\n    query: schemaConfig.query && schemaConfig.query.name,\n    mutation: schemaConfig.mutation && schemaConfig.mutation.name,\n    subscription: schemaConfig.subscription && schemaConfig.subscription.name\n  };\n\n  if (schemaDef) {\n    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {\n      var _ref2 = _schemaDef$operationT2[_i6];\n      var operation = _ref2.operation;\n      var type = _ref2.type;\n      operationTypes[operation] = type.name.value;\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {\n    var schemaExt = schemaExts[_i8];\n\n    if (schemaExt.operationTypes) {\n      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {\n        var _ref4 = _schemaExt$operationT2[_i10];\n        var _operation = _ref4.operation;\n        var _type = _ref4.type;\n        operationTypes[_operation] = _type.name.value;\n      }\n    }\n  } // Support both original legacy names and extended legacy names.\n\n\n  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    query: getMaybeTypeByName(operationTypes.query),\n    mutation: getMaybeTypeByName(operationTypes.mutation),\n    subscription: getMaybeTypeByName(operationTypes.subscription),\n    types: objectValues(typeMap),\n    directives: getMergedDirectives(),\n    astNode: schemaDef || schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),\n    allowedLegacyNames: allowedLegacyNames\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function getMaybeTypeByName(typeName) {\n    return typeName ? typeMap[typeName] : null;\n  }\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    existingDirectives || devAssert(0, 'schema must have default directives');\n    return existingDirectives.concat(directiveDefs.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    } else if (isScalarType(type)) {\n      return extendScalarType(type);\n    } else if (isObjectType(type)) {\n      return extendObjectType(type);\n    } else if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    } else if (isUnionType(type)) {\n      return extendUnionType(type);\n    } else if (isEnumType(type)) {\n      return extendEnumType(type);\n    } else if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // Not reachable. All possible types have been considered.\n\n\n    /* istanbul ignore next */\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread({}, config, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendInputObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInputObjectType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread({}, field, {\n            type: replaceType(field.type)\n          });\n        }), {}, keyValMap(fieldNodes, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return astBuilder.buildInputField(field);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[type.name] || [];\n    var valueNodes = flatMap(extensions, function (node) {\n      return node.values || [];\n    });\n    return new GraphQLEnumType(_objectSpread({}, config, {\n      values: _objectSpread({}, config.values, {}, keyValMap(valueNodes, function (value) {\n        return value.name.value;\n      }, function (value) {\n        return astBuilder.buildEnumValue(value);\n      })),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    return new GraphQLScalarType(_objectSpread({}, config, {\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var interfaceNodes = flatMap(extensions, function (node) {\n      return node.interfaces || [];\n    });\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLObjectType(_objectSpread({}, config, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var fieldNodes = flatMap(extensions, function (node) {\n      return node.fields || [];\n    });\n    return new GraphQLInterfaceType(_objectSpread({}, config, {\n      fields: function fields() {\n        return _objectSpread({}, mapValue(config.fields, extendField), {}, keyValMap(fieldNodes, function (node) {\n          return node.name.value;\n        }, function (node) {\n          return astBuilder.buildField(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var config = type.toConfig();\n    var extensions = typeExtsMap[config.name] || [];\n    var typeNodes = flatMap(extensions, function (node) {\n      return node.types || [];\n    });\n    return new GraphQLUnionType(_objectSpread({}, config, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {\n          return astBuilder.getNamedType(node);\n        }));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread({}, field, {\n      type: replaceType(field.type),\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread({}, arg, {\n      type: replaceType(arg.type)\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}