{"ast":null,"code":"import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from '../../language/predicates';\nimport { specifiedScalarTypes } from '../../type/scalars';\nexport function unknownTypeMessage(typeName, suggestedTypes) {\n  return \"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNames(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var definitionNode = ancestors[2] || parent;\n        var isSDL = isSDLNode(definitionNode);\n\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(unknownTypeMessage(typeName, suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\n\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return Boolean(value && !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value)));\n}","map":{"version":3,"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","unknownTypeMessage","typeName","suggestedTypes","concat","map","x","KnownTypeNames","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","NamedType","node","_1","parent","_2","ancestors","definitionNode","isSDL","isSDLNode","isSpecifiedScalarName","specifiedScalarsNames","reportError","type","indexOf","Boolean","Array","isArray"],"sources":["C:/Users/RiniPeni/Documents/Developer/ReactApps/LeCookBook/client/node_modules/graphql/validation/rules/KnownTypeNames.mjs"],"sourcesContent":["import didYouMean from '../../jsutils/didYouMean';\nimport suggestionList from '../../jsutils/suggestionList';\nimport { GraphQLError } from '../../error/GraphQLError';\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from '../../language/predicates';\nimport { specifiedScalarTypes } from '../../type/scalars';\nexport function unknownTypeMessage(typeName, suggestedTypes) {\n  return \"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes.map(function (x) {\n    return \"\\\"\".concat(x, \"\\\"\");\n  }));\n}\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNames(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var definitionNode = ancestors[2] || parent;\n        var isSDL = isSDLNode(definitionNode);\n\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(unknownTypeMessage(typeName, suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\n\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return Boolean(value && !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}